# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.9
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package clWRAP;
use base qw(Exporter);
use base qw(DynaLoader);
package clWRAPc;
bootstrap clWRAP;
package clWRAP;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package clWRAP;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package clWRAP;


############# Class : clWRAP::CAObj ##############

package clWRAP::CAObj;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clWRAPc::delete_CAObj($self);
        delete $OWNER{$self};
    }
}

*getObjectId = *clWRAPc::CAObj_getObjectId;
*takeRef = *clWRAPc::CAObj_takeRef;
*releaseRef = *clWRAPc::CAObj_releaseRef;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clWRAP::CASignalingObj ##############

package clWRAP::CASignalingObj;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = clWRAPc::new_CASignalingObj(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clWRAPc::delete_CASignalingObj($self);
        delete $OWNER{$self};
    }
}

*unWrap = *clWRAPc::CASignalingObj_unWrap;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clWRAP::CASignalingCallbackObj ##############

package clWRAP::CASignalingCallbackObj;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = clWRAPc::new_CASignalingCallbackObj(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clWRAPc::delete_CASignalingCallbackObj($self);
        delete $OWNER{$self};
    }
}

*unWrap = *clWRAPc::CASignalingCallbackObj_unWrap;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clWRAP::CASignalingEventObj ##############

package clWRAP::CASignalingEventObj;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = clWRAPc::new_CASignalingEventObj(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clWRAPc::delete_CASignalingEventObj($self);
        delete $OWNER{$self};
    }
}

*unWrap = *clWRAPc::CASignalingEventObj_unWrap;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clWRAP::CASignalingCallEventObj ##############

package clWRAP::CASignalingCallEventObj;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = clWRAPc::new_CASignalingCallEventObj(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clWRAPc::delete_CASignalingCallEventObj($self);
        delete $OWNER{$self};
    }
}

*unWrap = *clWRAPc::CASignalingCallEventObj_unWrap;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clWRAP::CASessionCallObj ##############

package clWRAP::CASessionCallObj;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = clWRAPc::new_CASessionCallObj(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clWRAPc::delete_CASessionCallObj($self);
        delete $OWNER{$self};
    }
}

*unWrap = *clWRAPc::CASessionCallObj_unWrap;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clWRAP::CASessionCallIceCallbackObj ##############

package clWRAP::CASessionCallIceCallbackObj;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = clWRAPc::new_CASessionCallIceCallbackObj(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clWRAPc::delete_CASessionCallIceCallbackObj($self);
        delete $OWNER{$self};
    }
}

*unWrap = *clWRAPc::CASessionCallIceCallbackObj_unWrap;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clWRAP::CAEngine ##############

package clWRAP::CAEngine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clWRAP::CAObj clWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clWRAPc::delete_CAEngine($self);
        delete $OWNER{$self};
    }
}

*getObjectId = *clWRAPc::CAEngine_getObjectId;
*init = *clWRAPc::CAEngine_init;
*deInit = *clWRAPc::CAEngine_deInit;
*isInitialized = *clWRAPc::CAEngine_isInitialized;
*setDebugLevel = *clWRAPc::CAEngine_setDebugLevel;
*setSSLCertificates = *clWRAPc::CAEngine_setSSLCertificates;
*setVideoPrefSize = *clWRAPc::CAEngine_setVideoPrefSize;
*setVideoFps = *clWRAPc::CAEngine_setVideoFps;
*setVideoBandwidthUpMax = *clWRAPc::CAEngine_setVideoBandwidthUpMax;
*setVideoBandwidthDownMax = *clWRAPc::CAEngine_setVideoBandwidthDownMax;
*setVideoMotionRank = *clWRAPc::CAEngine_setVideoMotionRank;
*setVideoCongestionCtrlEnabled = *clWRAPc::CAEngine_setVideoCongestionCtrlEnabled;
*setVideoJbEnabled = *clWRAPc::CAEngine_setVideoJbEnabled;
*setVideoAvpfTail = *clWRAPc::CAEngine_setVideoAvpfTail;
*setVideoZeroArtifactsEnabled = *clWRAPc::CAEngine_setVideoZeroArtifactsEnabled;
*setAudioEchoSuppEnabled = *clWRAPc::CAEngine_setAudioEchoSuppEnabled;
*setAudioEchoTail = *clWRAPc::CAEngine_setAudioEchoTail;
*addNattIceServer = *clWRAPc::CAEngine_addNattIceServer;
*clearNattIceServers = *clWRAPc::CAEngine_clearNattIceServers;
*setNattIceStunEnabled = *clWRAPc::CAEngine_setNattIceStunEnabled;
*setNattIceTurnEnabled = *clWRAPc::CAEngine_setNattIceTurnEnabled;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clWRAP::CASignalingEvent ##############

package clWRAP::CASignalingEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clWRAP::CAObj clWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = clWRAPc::new_CASignalingEvent(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clWRAPc::delete_CASignalingEvent($self);
        delete $OWNER{$self};
    }
}

*getObjectId = *clWRAPc::CASignalingEvent_getObjectId;
*getType = *clWRAPc::CASignalingEvent_getType;
*getDescription = *clWRAPc::CASignalingEvent_getDescription;
*getDataPtr = *clWRAPc::CASignalingEvent_getDataPtr;
*getDataSize = *clWRAPc::CASignalingEvent_getDataSize;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clWRAP::CASignalingCallEvent ##############

package clWRAP::CASignalingCallEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clWRAP::CASignalingEvent clWRAP );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = clWRAPc::new_CASignalingCallEvent(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clWRAPc::delete_CASignalingCallEvent($self);
        delete $OWNER{$self};
    }
}

*getObjectId = *clWRAPc::CASignalingCallEvent_getObjectId;
*getType = *clWRAPc::CASignalingCallEvent_getType;
*getFrom = *clWRAPc::CASignalingCallEvent_getFrom;
*getTo = *clWRAPc::CASignalingCallEvent_getTo;
*getCallId = *clWRAPc::CASignalingCallEvent_getCallId;
*getTransacId = *clWRAPc::CASignalingCallEvent_getTransacId;
*getSdp = *clWRAPc::CASignalingCallEvent_getSdp;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clWRAP::CASignalingCallback ##############

package clWRAP::CASignalingCallback;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clWRAP::CAObj clWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clWRAPc::delete_CASignalingCallback($self);
        delete $OWNER{$self};
    }
}

*onEventNet = *clWRAPc::CASignalingCallback_onEventNet;
*onEventCall = *clWRAPc::CASignalingCallback_onEventCall;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clWRAP::CASignaling ##############

package clWRAP::CASignaling;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clWRAP::CAObj clWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clWRAPc::delete_CASignaling($self);
        delete $OWNER{$self};
    }
}

*getObjectId = *clWRAPc::CASignaling_getObjectId;
*setCallback = *clWRAPc::CASignaling_setCallback;
*isConnected = *clWRAPc::CASignaling_isConnected;
*isReady = *clWRAPc::CASignaling_isReady;
*connect = *clWRAPc::CASignaling_connect;
*sendData = *clWRAPc::CASignaling_sendData;
*disConnect = *clWRAPc::CASignaling_disConnect;
*newObj = *clWRAPc::CASignaling_newObj;
*getCredUserId = *clWRAPc::CASignaling_getCredUserId;
*getCredPassword = *clWRAPc::CASignaling_getCredPassword;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clWRAP::CASession ##############

package clWRAP::CASession;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clWRAP::CAObj clWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clWRAPc::delete_CASession($self);
        delete $OWNER{$self};
    }
}

*getObjectId = *clWRAPc::CASession_getObjectId;
*getType = *clWRAPc::CASession_getType;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clWRAP::CASessionCallIceCallback ##############

package clWRAP::CASessionCallIceCallback;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clWRAP::CAObj clWRAP );
%OWNER = ();
%ITERATORS = ();
*onStateChanged = *clWRAPc::CASessionCallIceCallback_onStateChanged;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clWRAPc::delete_CASessionCallIceCallback($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clWRAP::CASessionCall ##############

package clWRAP::CASessionCall;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clWRAP::CASession clWRAP );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clWRAPc::delete_CASessionCall($self);
        delete $OWNER{$self};
    }
}

*getObjectId = *clWRAPc::CASessionCall_getObjectId;
*setIceCallback = *clWRAPc::CASessionCall_setIceCallback;
*setVideoDisplays = *clWRAPc::CASessionCall_setVideoDisplays;
*call = *clWRAPc::CASessionCall_call;
*acceptEvent = *clWRAPc::CASessionCall_acceptEvent;
*rejectEvent = *clWRAPc::CASessionCall_rejectEvent;
*setMute = *clWRAPc::CASessionCall_setMute;
*hangup = *clWRAPc::CASessionCall_hangup;
*setVideoFps = *clWRAPc::CASessionCall_setVideoFps;
*setVideoBandwidthUploadMax = *clWRAPc::CASessionCall_setVideoBandwidthUploadMax;
*setVideoBandwidthDownloadMax = *clWRAPc::CASessionCall_setVideoBandwidthDownloadMax;
*getCallId = *clWRAPc::CASessionCall_getCallId;
*getMediaType = *clWRAPc::CASessionCall_getMediaType;
*getIceState = *clWRAPc::CASessionCall_getIceState;
*newObj = *clWRAPc::CASessionCall_newObj;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package clWRAP;

*CADebugLevel_Info = *clWRAPc::CADebugLevel_Info;
*CADebugLevel_Warn = *clWRAPc::CADebugLevel_Warn;
*CADebugLevel_Error = *clWRAPc::CADebugLevel_Error;
*CADebugLevel_Fatal = *clWRAPc::CADebugLevel_Fatal;
*CASignalingEventType_NetConnected = *clWRAPc::CASignalingEventType_NetConnected;
*CASignalingEventType_NetReady = *clWRAPc::CASignalingEventType_NetReady;
*CASignalingEventType_NetData = *clWRAPc::CASignalingEventType_NetData;
*CASignalingEventType_NetDisconnected = *clWRAPc::CASignalingEventType_NetDisconnected;
*CASignalingEventType_NetError = *clWRAPc::CASignalingEventType_NetError;
*CASignalingEventType_Call = *clWRAPc::CASignalingEventType_Call;
*CAMediaType_None = *clWRAPc::CAMediaType_None;
*CAMediaType_Audio = *clWRAPc::CAMediaType_Audio;
*CAMediaType_Video = *clWRAPc::CAMediaType_Video;
*CAMediaType_ScreenCast = *clWRAPc::CAMediaType_ScreenCast;
*CAMediaType_AudioVideo = *clWRAPc::CAMediaType_AudioVideo;
*CAMediaType_All = *clWRAPc::CAMediaType_All;
*CAIceState_None = *clWRAPc::CAIceState_None;
*CAIceState_Failed = *clWRAPc::CAIceState_Failed;
*CAIceState_GatheringDone = *clWRAPc::CAIceState_GatheringDone;
*CAIceState_Connected = *clWRAPc::CAIceState_Connected;
*CAIceState_Teminated = *clWRAPc::CAIceState_Teminated;
*CASessionType_None = *clWRAPc::CASessionType_None;
*CASessionType_Call = *clWRAPc::CASessionType_Call;
1;
